// Code generated by execgen; DO NOT EDIT.

package exectoy

type selEQIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selEQIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] == p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] == p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selEQIntIntConstOp) Init() {}

type selEQIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selEQIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] == col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] == col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selEQIntIntOp) Init() {}

type selEQDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selEQDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] == p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] == p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selEQDoubleDoubleConstOp) Init() {}

type selEQDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selEQDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] == col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] == col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selEQDoubleDoubleOp) Init() {}

type selNEIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selNEIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] != p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] != p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selNEIntIntConstOp) Init() {}

type selNEIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selNEIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] != col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] != col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selNEIntIntOp) Init() {}

type selNEDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selNEDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] != p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] != p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selNEDoubleDoubleConstOp) Init() {}

type selNEDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selNEDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] != col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] != col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selNEDoubleDoubleOp) Init() {}

type selLTIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selLTIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] < p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] < p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selLTIntIntConstOp) Init() {}

type selLTIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selLTIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] < col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] < col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selLTIntIntOp) Init() {}

type selLTDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selLTDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] < p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] < p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selLTDoubleDoubleConstOp) Init() {}

type selLTDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selLTDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] < col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] < col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selLTDoubleDoubleOp) Init() {}

type selLTEIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selLTEIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] <= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] <= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selLTEIntIntConstOp) Init() {}

type selLTEIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selLTEIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] <= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] <= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selLTEIntIntOp) Init() {}

type selLTEDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selLTEDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] <= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] <= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selLTEDoubleDoubleConstOp) Init() {}

type selLTEDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selLTEDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] <= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] <= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selLTEDoubleDoubleOp) Init() {}

type selGTIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selGTIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] > p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] > p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selGTIntIntConstOp) Init() {}

type selGTIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selGTIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] > col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] > col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selGTIntIntOp) Init() {}

type selGTDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selGTDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] > p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] > p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selGTDoubleDoubleConstOp) Init() {}

type selGTDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selGTDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] > col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] > col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selGTDoubleDoubleOp) Init() {}

type selGTEIntIntConstOp struct {
	input ExecOp

	col1Idx  int
	constArg int
}

func (p *selGTEIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] >= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] >= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selGTEIntIntConstOp) Init() {}

type selGTEIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selGTEIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] >= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] >= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selGTEIntIntOp) Init() {}

type selGTEDoubleDoubleConstOp struct {
	input ExecOp

	col1Idx  int
	constArg float64
}

func (p *selGTEDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	idx := 0
	n := flow.n
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] >= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] >= p.constArg {
				flow.sel[idx] = i
				idx++
			}
		}
	}
	flow.n = idx
	flow.useSel = true
	return flow
}

func (p selGTEDoubleDoubleConstOp) Init() {}

type selGTEDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int
}

func (p *selGTEDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	n := flow.n

	idx := 0
	if flow.useSel {
		for s := 0; s < n; s++ {
			i := flow.sel[s]
			if col1[i] >= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
	} else {
		for i := 0; i < n; i++ {
			if col1[i] >= col2[i] {
				flow.sel[idx] = i
				idx++
			}
		}
		flow.useSel = true
	}
	flow.n = idx
	return flow
}

func (p selGTEDoubleDoubleOp) Init() {}
