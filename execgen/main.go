package main

import (
	"flag"
	"fmt"
	"io"
	"os"

	"text/template"
)

type op int

const (
	invalidOp op = iota
	plusOp
	minusOp
	mulOp
	divOp

	eqOp
	neOp
	ltOp
	lteOp
	gtOp
	gteOp
)

type typ int

const (
	invalidTyp typ = iota
	intTyp
	doubleTyp
	boolTyp
)

type typDef struct {
	Name  string
	GoTyp string
}

var typs = map[typ]typDef{
	intTyp: typDef{
		Name:  "Int",
		GoTyp: "int",
	},
	doubleTyp: typDef{
		Name:  "Double",
		GoTyp: "float64",
	},
	boolTyp: typDef{
		Name:  "Bool",
		GoTyp: "bool",
	},
}

var opNames = map[op]string{
	plusOp:  "Plus",
	minusOp: "Minus",
	mulOp:   "Mul",
	eqOp:    "EQ",
	neOp:    "NE",
	ltOp:    "LT",
	lteOp:   "LTE",
	gtOp:    "GT",
	gteOp:   "GTE",
}

type overload struct {
	Name   string
	OpStr  string
	LTyp   typDef
	RTyp   typDef
	RetTyp typDef
}

func makeOverload(t typ, opStr string) overload {
	return overload{
		OpStr:  opStr,
		LTyp:   typs[t],
		RTyp:   typs[t],
		RetTyp: typs[t],
	}
}

func makePredOverload(t typ, opStr string) overload {
	return overload{
		OpStr:  opStr,
		LTyp:   typs[t],
		RTyp:   typs[t],
		RetTyp: typs[boolTyp],
	}
}

var opMap = map[op][]overload{
	plusOp: {
		makeOverload(intTyp, "+"),
		makeOverload(doubleTyp, "+"),
	},
	minusOp: {
		makeOverload(intTyp, "-"),
		makeOverload(doubleTyp, "-"),
	},
	mulOp: {
		makeOverload(intTyp, "-"),
		makeOverload(doubleTyp, "-"),
	},
	divOp: {
		makeOverload(intTyp, "/"),
		makeOverload(doubleTyp, "/"),
	},
	eqOp: {
		makePredOverload(intTyp, "=="),
		makePredOverload(doubleTyp, "=="),
	},
	neOp: {
		makePredOverload(intTyp, "!="),
		makePredOverload(doubleTyp, "!="),
	},
	ltOp: {
		makePredOverload(intTyp, "<"),
		makePredOverload(doubleTyp, "<"),
	},
	lteOp: {
		makePredOverload(intTyp, "<="),
		makePredOverload(doubleTyp, "<="),
	},
	gtOp: {
		makePredOverload(intTyp, ">"),
		makePredOverload(doubleTyp, ">"),
	},
	gteOp: {
		makePredOverload(intTyp, ">="),
		makePredOverload(doubleTyp, ">="),
	},
}

func init() {
	for i := range opMap {
		for j := range opMap[i] {
			opMap[i][j].Name = opNames[i]
		}
	}
}

func genProj(wr io.Writer) error {
	tmpl, err := template.New("proj").Parse(`// Code generated by execgen; DO NOT EDIT.

package exectoy

{{define "opConstName"}}proj{{.Name}}{{.LTyp.Name}}{{.RTyp.Name}}ConstOp{{end}}
{{define "opName"}}proj{{.Name}}{{.LTyp.Name}}{{.RTyp.Name}}Op{{end}}

{{- range .}}
{{- range .}}
type {{template "opConstName" .}} struct {
	input ExecOp

	colIdx   int
	constArg {{.RTyp.GoTyp}}

	outputIdx int
}

func (p *{{template "opConstName" .}}) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].({{.RetTyp.GoTyp}}Column)
	col := flow.b[p.colIdx].({{.LTyp.GoTyp}}Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] {{.OpStr}} p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] {{.OpStr}} p.constArg
		}
	}
	return flow
}

func (p {{template "opConstName" .}}) Init() {}

type {{template "opName" .}} struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *{{template "opName" .}}) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].({{.RetTyp.GoTyp}}Column)
	col1 := flow.b[p.col1Idx].({{.LTyp.GoTyp}}Column)
	col2 := flow.b[p.col2Idx].({{.RTyp.GoTyp}}Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	}
	return flow
}

func (p {{template "opName" .}}) Init() {}
{{- end}}
{{- end}}
`)
	if err != nil {
		return err
	}

	return tmpl.Execute(wr, opMap)
}

var out = flag.String("out", "", "output file")

func usage() {
	fmt.Fprintf(os.Stderr, `usage: execgen [-out filename] command

The commands are:
	proj    generate projection code

`)
	flag.PrintDefaults()
	os.Exit(2)
}

var generators = map[string]func(io.Writer) error{
	"proj": genProj,
	"sel":  genSel,
}

func main() {
	flag.Parse()
	flag.Usage = usage
	if len(flag.Args()) != 1 {
		usage()
	}

	cmd := flag.Args()[0]

	if gen := generators[cmd]; gen != nil {
		wr := os.Stdout
		if *out != "" {
			file, err := os.Create(*out)
			if err != nil {
				panic(err)
			}
			defer file.Close()

			wr = file
		}
		if err := gen(wr); err != nil {
			panic(err)
		}
	} else {
		usage()
	}
}
