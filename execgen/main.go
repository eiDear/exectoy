package main

import (
	"os"

	"text/template"
)

type opDef struct {
	Name  string
	OpStr string
}

var input = struct {
	Ops []opDef
}{
	Ops: []opDef{
		{
			Name:  "Plus",
			OpStr: "+",
		},
		{
			Name:  "Minus",
			OpStr: "-",
		},
		{
			Name:  "Div",
			OpStr: "/",
		},
		{
			Name:  "Mul",
			OpStr: "*",
		},
	},
}

func main() {
	tmpl, err := template.New("proj").Parse(`// Code generated by execgen; DO NOT EDIT.

package exectoy

{{range .Ops}}
type proj{{.Name}}IntIntConst struct {
	input ExecOp

	intIdx   int
	constArg int

	outputIdx int
}

func (p *proj{{.Name}}IntIntConst) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	intCol := flow.b[p.intIdx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = intCol[i] {{.OpStr}} p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = intCol[i] {{.OpStr}} p.constArg
		}
	}
	return flow
}

func (p proj{{.Name}}IntIntConst) Init() {}

type proj{{.Name}}IntInt struct {
	input ExecOp

	int1Idx int
	int2Idx int

	outputIdx int
}

func (p *proj{{.Name}}IntInt) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col1 := flow.b[p.int1Idx].(intColumn)
	col2 := flow.b[p.int2Idx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	}
	return flow
}

func (p proj{{.Name}}IntInt) Init() {}
{{end}}
`)
	if err != nil {
		panic(err)
	}

	err = tmpl.Execute(os.Stdout, input)
	if err != nil {
		panic(err)
	}
}
