package main

import (
	"os"

	"text/template"
)

type typDef struct {
	Name  string
	GoTyp string
	Ops   []opDef
}

type opDef struct {
	Name  string
	OpStr string
}

var input = struct {
	Types []typDef
}{
	Types: []typDef{
		{
			Name:  "Int",
			GoTyp: "int",
			Ops: []opDef{
				{
					Name:  "Plus",
					OpStr: "+",
				},
				{
					Name:  "Minus",
					OpStr: "-",
				},
				{
					Name:  "Div",
					OpStr: "/",
				},
				{
					Name:  "Mul",
					OpStr: "*",
				},
			},
		},
		{
			Name:  "Double",
			GoTyp: "float64",
			Ops: []opDef{
				{
					Name:  "Plus",
					OpStr: "+",
				},
				{
					Name:  "Minus",
					OpStr: "-",
				},
				{
					Name:  "Div",
					OpStr: "/",
				},
				{
					Name:  "Mul",
					OpStr: "*",
				},
			},
		},
	},
}

func main() {
	tmpl, err := template.New("proj").Parse(`// Code generated by execgen; DO NOT EDIT.

package exectoy

{{range $typ := .Types}}
{{range .Ops}}
type proj{{.Name}}{{$typ.Name}}{{$typ.Name}}Const struct {
	input ExecOp

	colIdx   int
	constArg {{$typ.GoTyp}}

	outputIdx int
}

func (p *proj{{.Name}}{{$typ.Name}}{{$typ.Name}}Const) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].({{$typ.GoTyp}}Column)
	col := flow.b[p.colIdx].({{$typ.GoTyp}}Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] {{.OpStr}} p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] {{.OpStr}} p.constArg
		}
	}
	return flow
}

func (p proj{{.Name}}{{$typ.Name}}{{$typ.Name}}Const) Init() {}

type proj{{.Name}}{{$typ.Name}}{{$typ.Name}} struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *proj{{.Name}}{{$typ.Name}}{{$typ.Name}}) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].({{$typ.GoTyp}}Column)
	col1 := flow.b[p.col1Idx].({{$typ.GoTyp}}Column)
	col2 := flow.b[p.col2Idx].({{$typ.GoTyp}}Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] {{.OpStr}} col2[i]
		}
	}
	return flow
}

func (p proj{{.Name}}{{$typ.Name}}{{$typ.Name}}) Init() {}
{{end}}
{{end}}
`)
	if err != nil {
		panic(err)
	}

	err = tmpl.Execute(os.Stdout, input)
	if err != nil {
		panic(err)
	}
}
