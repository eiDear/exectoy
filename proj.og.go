// Code generated by execgen; DO NOT EDIT.

package exectoy



type projPlusIntIntConstOp struct {
	input ExecOp

	colIdx   int
	constArg int

	outputIdx int
}

func (p *projPlusIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col := flow.b[p.colIdx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] + p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] + p.constArg
		}
	}
	return flow
}

func (p projPlusIntIntConstOp) Init() {}

type projPlusIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return flow
}

func (p projPlusIntIntOp) Init() {}
type projPlusDoubleDoubleConstOp struct {
	input ExecOp

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projPlusDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col := flow.b[p.colIdx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] + p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] + p.constArg
		}
	}
	return flow
}

func (p projPlusDoubleDoubleConstOp) Init() {}

type projPlusDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return flow
}

func (p projPlusDoubleDoubleOp) Init() {}
type projMinusIntIntConstOp struct {
	input ExecOp

	colIdx   int
	constArg int

	outputIdx int
}

func (p *projMinusIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col := flow.b[p.colIdx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] - p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] - p.constArg
		}
	}
	return flow
}

func (p projMinusIntIntConstOp) Init() {}

type projMinusIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return flow
}

func (p projMinusIntIntOp) Init() {}
type projMinusDoubleDoubleConstOp struct {
	input ExecOp

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMinusDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col := flow.b[p.colIdx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] - p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] - p.constArg
		}
	}
	return flow
}

func (p projMinusDoubleDoubleConstOp) Init() {}

type projMinusDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return flow
}

func (p projMinusDoubleDoubleOp) Init() {}
type projMulIntIntConstOp struct {
	input ExecOp

	colIdx   int
	constArg int

	outputIdx int
}

func (p *projMulIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col := flow.b[p.colIdx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] - p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] - p.constArg
		}
	}
	return flow
}

func (p projMulIntIntConstOp) Init() {}

type projMulIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMulIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return flow
}

func (p projMulIntIntOp) Init() {}
type projMulDoubleDoubleConstOp struct {
	input ExecOp

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMulDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col := flow.b[p.colIdx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] - p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] - p.constArg
		}
	}
	return flow
}

func (p projMulDoubleDoubleConstOp) Init() {}

type projMulDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMulDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return flow
}

func (p projMulDoubleDoubleOp) Init() {}
type projDivIntIntConstOp struct {
	input ExecOp

	colIdx   int
	constArg int

	outputIdx int
}

func (p *projDivIntIntConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col := flow.b[p.colIdx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] / p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] / p.constArg
		}
	}
	return flow
}

func (p projDivIntIntConstOp) Init() {}

type projDivIntIntOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivIntIntOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(intColumn)
	col1 := flow.b[p.col1Idx].(intColumn)
	col2 := flow.b[p.col2Idx].(intColumn)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return flow
}

func (p projDivIntIntOp) Init() {}
type projDivDoubleDoubleConstOp struct {
	input ExecOp

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projDivDoubleDoubleConstOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col := flow.b[p.colIdx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col[i] / p.constArg
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col[i] / p.constArg
		}
	}
	return flow
}

func (p projDivDoubleDoubleConstOp) Init() {}

type projDivDoubleDoubleOp struct {
	input ExecOp

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivDoubleDoubleOp) Next() dataFlow {
	flow := p.input.Next()

	projCol := flow.b[p.outputIdx].(float64Column)
	col1 := flow.b[p.col1Idx].(float64Column)
	col2 := flow.b[p.col2Idx].(float64Column)
	if flow.useSel {
		for s := 0; s < flow.n; s++ {
			i := flow.sel[s]
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		for i := 0; i < flow.n; i++ {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return flow
}

func (p projDivDoubleDoubleOp) Init() {}
